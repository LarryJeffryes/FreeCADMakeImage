From 7d1449daf8225bc0df9376a9d7446d033f3bd5e1 Mon Sep 17 00:00:00 2001
From: "Zheng, Lei" <realthunder.dev@gmail.com>
Date: Fri, 5 Jun 2020 21:40:53 +0800
Subject: [PATCH] (Re)implement smoothBorder in SoShadowGroup

Inspred by the book 'Computer Graphics Programming in OpenGL with C++'
by V. Scott Gordon, John L. Clevenger.

https://books.google.com.sg/books?id=GomCDwAAQBAJ&lpg=PT290&vq=soft%20shadow&pg=PT298#v=onepage&q&f=false

The sampling is done on the shadow map texture and performed in the
fragment shader. The smoothBorder feild is interpreted as follow,

0 ~ 0.1, uses 2x2 samples with dithering, and swidth (the shadow spread
width) is derived as smoothBorder * 50. See the section 'Soft shadow' in
the book for more details.

From 0.1 onwards, the first fractional digits specifies the cube size
(+2) for sampling, that is, 0.1 means a cube of 3x3, and 0.2 for 4x4,
etc. up to maximum 8x8. The 2nd digits onwards determins the spread just
like above.

There is a shortcoming of the current implementation. The sampling spread
(swidth) is dependent on the texture matrix. In other words, the higher the
scale implied by texture mapping, the smaller the swidth shall be used. A
swidth that is too big will produce incorrect shadows.
---
 src/shadows/SoShadowGroup.cpp | 73 ++++++++++++++++++++++++++++++-----
 1 file changed, 63 insertions(+), 10 deletions(-)

diff --git a/src/shadows/SoShadowGroup.cpp b/src/shadows/SoShadowGroup.cpp
index 20382aac9..73f4965b5 100644
--- a/src/shadows/SoShadowGroup.cpp
+++ b/src/shadows/SoShadowGroup.cpp
@@ -1647,6 +1647,8 @@ SoShadowGroupP::setFragmentShader(SoState * state)
 {
   int i;
 
+  float smoothing = PUBLIC(this)->smoothBorder.getValue();
+
   SoShaderGenerator & gen = this->fragmentgenerator;
   gen.reset(FALSE);
 
@@ -1741,18 +1743,60 @@ SoShadowGroupP::setFragmentShader(SoState * state)
   gen.addMainStatement("vec3 color = perVertexColor;\n"
                        "vec3 scolor = vec3(0.0);\n"
                        "float dist;\n"
-                       "float shadeFactor;\n"
+                       "float shadeFactor = 0.0;\n"
                        "vec3 coord;\n"
                        "vec4 map;\n"
                        "mydiffuse.a *= texcolor.a;\n");
 
   if (perpixelspot) {
+    SbString str;
+    int count;
+#define MAX_OFFSET_COUNT 8
+    float offsets[MAX_OFFSET_COUNT*MAX_OFFSET_COUNT*2];
+    if (smoothing > 0.1f) {
+      gen.addMainStatement("vec2 offset = vec2(0.0, 0.0);\n");
+      float swidth = (smoothing - int(smoothing*10)*0.1f) * 50.0f;
+      str.sprintf("float swidth = %f;\n", swidth);
+      gen.addMainStatement(str);
+      count = (int)(smoothing * 10) + 2;
+      if (count > MAX_OFFSET_COUNT) count = MAX_OFFSET_COUNT;
+      for (int j=0;j<count;++j) {
+        for (int k=0;k<count;++k) {
+            offsets[j*count*2 + k*2] = k-count*0.5f;
+            offsets[j*count*2 + k*2 + 1] = j-count*0.5f;
+        }
+      }
+      count *= count;
+    }
+    else if (smoothing > 0.0f) {
+      gen.addMainStatement("vec2 offset = mod(floor(gl_FragCoord.xy),2.0);\n");
+      gen.addMainStatement("offset.y = -offset.y;\n");
+      float swidth = smoothing * 50.0f;
+      str.sprintf("float swidth = %f;\n", swidth);
+      gen.addMainStatement(str);
+      count = 4;
+      offsets[0] = -1.5f;
+      offsets[1] = 1.5f;
+      offsets[2] = -1.5f;
+      offsets[3] = -0.5f;
+      offsets[4] = 0.5f;
+      offsets[5] = 1.5f;
+      offsets[6] = 0.5f;
+      offsets[7] = -0.5f;
+    }
+    else {
+      gen.addMainStatement("vec2 offset = vec2(0.0, 0.0);\n");
+      gen.addMainStatement("float swidth = 0.0;\n");
+      count = 1;
+      offsets[0] = offsets[1] = 0.0f;
+    }
+
     SbBool spotlight = FALSE;
     SbBool dirlight = FALSE;
+
     for (i = 0; i < numshadowlights; i++) {
       SoShadowLightCache * cache = this->shadowlights[i];
       SbBool dirshadow = FALSE;
-      SbString str;
       SbBool normalspot = FALSE;
       SbString insidetest = "&& coord.x >= 0.0 && coord.x <= 1.0 && coord.y >= 0.0 && coord.y <= 1.0)";
 
@@ -1786,20 +1830,29 @@ SoShadowGroupP::setFragmentShader(SoState * state)
           addDirSpotLight(gen, cache->lightid, TRUE);
         }
       }
+
       str.sprintf("coord = 0.5 * (shadowCoord%d.xyz / shadowCoord%d.w + vec3(1.0));\n", i , i);
       gen.addMainStatement(str);
-      str.sprintf("map = texture2D(shadowMap%d, coord.xy);\n", i);
-      gen.addMainStatement(str);
+      for (int j=0; j<count; ++j) {
+        str.sprintf("map = texture2D(shadowMap%d, coord.xy + "
+                "(vec2(%f,%f)+offset.xy)*swidth*0.001*shadowCoord%d.w);\n",
+                i, offsets[j*2], offsets[j*2+1], i);
+        gen.addMainStatement(str);
 #ifdef USE_NEGATIVE
-      gen.addMainStatement("map = (map + vec4(1.0)) * 0.5;\n");
+        gen.addMainStatement("map = (map + vec4(1.0)) * 0.5;\n");
 #endif // USE_NEGATIVE
 #ifdef DISTRIBUTE_FACTOR
-      gen.addMainStatement("map.xy += map.zw / DISTRIBUTE_FACTOR;\n");
+        gen.addMainStatement("map.xy += map.zw / DISTRIBUTE_FACTOR;\n");
 #endif
-      str.sprintf("shadeFactor = ((map.x < 0.9999) && (shadowCoord%d.z > -1.0 %s) "
-                  "? VsmLookup(map, (dist - nearval%d) / (farval%d - nearval%d), EPSILON, THRESHOLD) : 1.0;\n",
-                  i, insidetest.getString(),i,i,i);
-      gen.addMainStatement(str);
+        str.sprintf("shadeFactor += ((map.x < 0.9999) && (shadowCoord%d.z > -1.0 %s) "
+                "? VsmLookup(map, (dist - nearval%d) / (farval%d - nearval%d), EPSILON, THRESHOLD) : 1.0;\n",
+                i, insidetest.getString(),i,i,i);
+        gen.addMainStatement(str);
+      }
+      if (count != 1) {
+        str.sprintf("shadeFactor /= %d.0;\n", count);
+        gen.addMainStatement(str);
+      }
 
       if (dirshadow) {
         SoShadowDirectionalLight * sl = static_cast<SoShadowDirectionalLight*> (light);
-- 
2.23.0

